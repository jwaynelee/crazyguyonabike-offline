Suggestions for an API on crazyguyonabike. The goal is to allow application like cgoab-offline to operate without binding to the fragile html side of the site.

<wiki:toc max_depth="3" />

=Style=

Options for invoking queries, either distinct URL per method, or one "API" URL and pass method as parameter. Whatever is easiest to implement.

Query like APIs would map to HTTP GET (ie, GetUserInfo and GetDocuments), whilst APIs that change state map to HTTP PUT (Login, Logout, CreatePage, AddPhoto).

=Versioning=

For simplicity might want to just have one single version. For upgrade perhaps having version in URL (or as query parameter) is desirable? For example:

`/api/v1/AddPage`

If new (mandatory) parameters are introduced this might break the API, so we could instead leave v1 alone and offer:

`/api/v2/AddPage`

Weblogs would show if anyone still using v1, which could over time be removed.

Introduces extra complexity on server side. Probably unnecessary.

=Data format=

Data can be returned from the server using some custom formatted string, CSV separated data, JSON or even XML.

|| custom string || Simple, but requires custom parsing. Not obvious how to treat structured data ||
|| CSV || Simple, need to make sure embedded "," handled in parser. Poor structured data support ||
|| JSON || Simple(ish). Useful if every want to use API from javascript. ||
|| XML || Complex. But good parser support, XPath to query structure. Very good with structured data ||

Tempting to use one format for simple calls (ie, GetUser), but better to be consistent at expense of making simple calls that extra bit harder to parse.

=Return codes=

The result of an API call is either a structured list of data or a simple result/return code. For consistency with unix/c APIs error codes would be expected to be negative. 0 indicates general success, whilst positive integers represent some meaningful data. For example:

|| DISABLED_METHOD || -200 || error, the method is currently disabled, allows temporary suspension of the service (if abuse detected etc) ||
|| INVALID_ARGUMENTS || -100 || error, arguments list is not valid (ie, missing or extra argument) ||
|| NOT_LOGGED_IN || -10 || error, attempt to use method before logging in ||
|| SUCCESS || 0 || ok ||
||  || 123456 || page_id returned from CreatePage method ||

==Session handling==

HTTP requests will contain any cookies set by the server. These cookies/header attributes are not listed in the API, however they will be present like any normal connection.

== !GetUserInfo ==

A simple query API to find the user-name and real-name of the current user. Can be used before explicitly logging in to check if an old session is still valid and thus avoid prompting the user for a password.

=== parameters ===

/* no parameters */

=== return ===

Structure containing:

|| username || "testuser" ||
|| realname || "John Doe" ||

or error code,

|| NOT_LOGGED_IN ||

== !LogIn ==

Logs into the server and establishes session. If no pre-existing session is found this must be done before any of the following methods (CreatePage etc) are used.

=== parameters ===

|| username || 
|| password ||

=== returns ===

Integer result:

|| SUCCESS || if credentials valid and log in succeeded ||
|| NOT_LOGGED_IN || if credentials invalid, no distinction is made if username or password was invalid ||
|| ACCOUNT_LOCKED || if repeated attempts are made to log in with incorrect password ||

Upon success there is a side-affect of creating the session cookie

== !LogOut ==

Logs out from the server, expected that the server will instruct client to clear it's cookie. May be used by server to clean up server side session object.

=== parameters ===
 
/* empty */
 
=== returns ===

|| SUCCESS || Always returned. An attempt to logout without first logging in is silently ignored. ||

Note, this has the side-affect of clearing the session cookie.

== !GetDocuments ==

Returns the list of documents authored by the currently logged in user.

=== parameters ===

/* no parameters */

=== returns ===

A list containing an entry for each document owned by the current user, each document has:

|| doc_id || ID of the document || 12345 ||
|| name || Name of the document || "My Journal" ||
|| status || Status of the document || "Completed Aug 2010" or "10 out of 100 days" ||
|| type || Type of document || JOURNAL or ARTICLE ||

== !CreatePage ==

Creates a new page in a document.

=== parameters ===

|| doc_id ||
|| title ||
|| headline ||
|| text ||
|| date ||
|| distance ||
|| indent ||
|| is_bold ||
|| is_italic ||
|| style ||
|| sequence || insertion point of page in the document. If "-1" then page is appended to the end ||

=== returns ===

|| page_id || 
|| NOT_LOGGED_IN ||
|| PAGE_OLDER_THAN_PREVIOUS ||
|| INVALID_PHOTO_TAG || if the text contains "###" tags that reference 
|| ... ||

== !AddPhoto ==

=== paramaters ===

|| page_id ||
|| comment ||
|| file || 
|| name || name of the photo, defaults top filename if empty ||

=== returns ===

|| SUCCESS || if photo was added ||
|| NOT_LOGGED_IN || 
|| PHOTO_ALREADY_EXISTS || if a photo with the same name already exists in the journal ||
|| ... ||


== ISSUES ==

At present a combination of CreatePage and then several calls to AddPhoto are used to upload a page. The result of this approach is that we are limited to only adding photos at the end of a page. It is not possible to call CreatePage with text containing "###" photo tags (as the photos won't exist!). An alternative approach would be to call CreatePage with empty text. Then call AddPhoto for each photo. Then call UpdatePage() with the actual text (containing embedded "###" tags). 